---
title: "在 ASP.NET Core 目的字串"
author: rick-anderson
description: "本文概述目的字串階層和多租用戶與 ASP.NET Core 資料保護 Api。"
keywords: "ASP.NET Core 資料保護和目的字串"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 9d18c287-e0e6-4541-b09c-7fed45c902d9
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: ce506710042bfb76015c3af991b17e018b78e970
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/10/2017
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="46cd9-104">目的階層和 ASP.NET Core 中的多租用戶</span><span class="sxs-lookup"><span data-stu-id="46cd9-104">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="46cd9-105">因為`IDataProtector`也是隱含`IDataProtectionProvider`，用途可以鏈結在一起。</span><span class="sxs-lookup"><span data-stu-id="46cd9-105">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="46cd9-106">就這個意義而言，`provider.CreateProtector([ "purpose1", "purpose2" ])`相當於`provider.CreateProtector("purpose1").CreateProtector("purpose2")`。</span><span class="sxs-lookup"><span data-stu-id="46cd9-106">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="46cd9-107">這可讓您透過資料保護系統一些有趣的階層式關聯性。</span><span class="sxs-lookup"><span data-stu-id="46cd9-107">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="46cd9-108">在先前範例中的[Contoso.Messaging.SecureMessage](purpose-strings.md#data-protection-contoso-purpose)，SecureMessage 元件可以呼叫`provider.CreateProtector("Contoso.Messaging.SecureMessage")`一次前期和私用到快取結果`_myProvide`欄位。</span><span class="sxs-lookup"><span data-stu-id="46cd9-108">In the earlier example of [Contoso.Messaging.SecureMessage](purpose-strings.md#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvide` field.</span></span> <span data-ttu-id="46cd9-109">未來的保護裝置，就可以建立透過呼叫`_myProvider.CreateProtector("User: username")`，而且會用於這些保護裝置保護個別訊息。</span><span class="sxs-lookup"><span data-stu-id="46cd9-109">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="46cd9-110">這可以也翻轉。</span><span class="sxs-lookup"><span data-stu-id="46cd9-110">This can also be flipped.</span></span> <span data-ttu-id="46cd9-111">請考慮單一邏輯應用程式與它自己的驗證和狀態管理系統，則可以設定多個租用戶 （CMS 似乎很合理） 和每個租用戶的主機。</span><span class="sxs-lookup"><span data-stu-id="46cd9-111">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="46cd9-112">概括性應用程式具有單一主要提供者，而且它會呼叫`provider.CreateProtector("Tenant 1")`和`provider.CreateProtector("Tenant 2")`來提供每個租用戶的資料保護系統自己隔離配量。</span><span class="sxs-lookup"><span data-stu-id="46cd9-112">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="46cd9-113">租用戶無法再衍生自己個別的保護裝置根據其自己的需求，但是無論他們嘗試手動他們無法建立相衝突的保護裝置與任何其他租用戶系統中。</span><span class="sxs-lookup"><span data-stu-id="46cd9-113">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="46cd9-114">以圖形方式，這被表示如下。</span><span class="sxs-lookup"><span data-stu-id="46cd9-114">Graphically, this is represented as below.</span></span>

![多組織用戶管理用途](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="46cd9-116">這是假設概括性的應用程式開發介面可供個別租用戶和租用戶，無法在伺服器上執行任意程式碼的應用程式控制項。</span><span class="sxs-lookup"><span data-stu-id="46cd9-116">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="46cd9-117">如果租用戶可以執行任意程式碼中，使用者無法執行中斷的隔離保證，私用反映或只無法直接讀取主要金鑰材料並衍生任何子機碼想。</span><span class="sxs-lookup"><span data-stu-id="46cd9-117">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="46cd9-118">資料保護系統實際上會使用預設的方塊超出設定的多租用戶的排序。</span><span class="sxs-lookup"><span data-stu-id="46cd9-118">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="46cd9-119">根據預設主要金鑰的資料會儲存在工作處理序帳戶的使用者設定檔資料夾 （或登錄中的，為 IIS 應用程式集區身分識別）。</span><span class="sxs-lookup"><span data-stu-id="46cd9-119">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="46cd9-120">但使用的單一帳戶來執行多個應用程式，實際上很常見，因此所有這些應用程式都會結束共用主要金鑰材料。</span><span class="sxs-lookup"><span data-stu-id="46cd9-120">But it is actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="46cd9-121">若要解決這個問題，資料保護系統會自動為整體目的鏈結中的第一個項目插入唯一-針對應用程式識別項。</span><span class="sxs-lookup"><span data-stu-id="46cd9-121">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="46cd9-122">這個隱含的目的是用來[隔離個別的應用程式](xref:security/data-protection/configuration/overview#per-application-isolation)彼此有效地將每個應用程式，因為唯一的租用戶系統，並保護裝置建立程序內看起來與上圖相同。</span><span class="sxs-lookup"><span data-stu-id="46cd9-122">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
